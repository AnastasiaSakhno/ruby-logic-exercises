3. Дан целочисленный массив. Вывести номер первого из тех его элементов, которые удовлетворяют двойному неравенству: A[0] < A[i] < A[-1]. Если таких элементов нет, то вывести [ ].
[1,2,3].each_with_index { |item, i| if(a[0]<a[i] && a[i]<a[-1]) then p i; break end }

6. Дан целочисленный массив. Преобразовать его, прибавив к четным числам последний элемент. Первый и последний элементы массива не изменять.
a = [1, 2, 3, 4, 5, 6]
a.each_with_index { |item, i| a[i] = item + a[-1] if(i!=0 && i!=a.size-1 && item.even?) }

9. Дан целочисленный массив. Заменить все положительные элементы на значение минимального.
a=[1,-5,2,-6,7]
a.each_with_index { |item, i| a[i] = a.min if item>0 }

12. Дан целочисленный массив. Заменить все отрицательные элементы на значение максимального.
a=[1,-5,2,-6,7]
a.each_with_index { |item, i| a[i] = a.max if item<0 }

15. Дан целочисленный массив. Проверить, образуют ли элементы арифметическую прогрессию. Если да, то вывести разность прогрессии, если нет - вывести nil.
a= [1, 2, 3, 4, 5, 6]
diff=a[1]-a[0]
a.each_with_index do |item, i|
  break nil if(i>1 && a[i]-a[i-1] != diff)
  break diff if i==a.size-1
end

18. Дан целочисленный массив. Найти количество его локальных минимумов.
min_count=0
a=[1,0,2,3,2,5,6,7,2,1,1]
a[1..a.size-2].select.with_index(1) { |item, i| a[i]<a[i-1] && a[i]<a[i+1] }.size

21. Дан целочисленный массив. Определить количество участков, на которых его элементы монотонно возрастают.
rise_count=0
a=[1,0,2,3,2,5,6,7,2,1,1]
to_grow=false
a.each_with_index do |item, i|
  next if i==0
  if(!to_grow && a[i]>a[i-1]) then rise_count+=1; to_grow=true end
  to_grow=false if(to_grow && a[i]<=a[i-1])
end
rise_count

24. Дано вещественное число R и массив вещественных чисел. Найти элемент массива, который наименее близок к данному числу.
r=1.1234567
a=[1.1, 2.3, 1.123, 3.14, -1.1]
head :129 > diff_with_min=(r-a.min).abs
 => 2.2234567
head :130 > diff_with_max=(r-a.max).abs
 => 2.0165433000000004
head :131 > diff_with_min > diff_with_max ? a.min : a.max
 => -1.1

27. Дан целочисленный массив. Преобразовать его, вставив после каждого положительного элемента нулевой элемент.
a=[1,-4,5,8,-3,-2,0,4]
Если имелось ввиду вставить ноль:
 => [1, -4, 5, 8, -3, -2, 0, 4]
head :135 > a.each_with_index { |item, i| a.insert(i+1,0) if item>0 }
 => [1, 0, -4, 5, 0, 8, 0, -3, -2, 0, 4, 0]
Если имелось ввиду вставить a[0]:
i=0
a.each { |item| if(i<a.size && item>0) then a.insert(i+1, a[0]); i+=1 end; i+=1 }

30. Дан целочисленный массив. Упорядочить его по убыванию.
a=[1, 0, -4, 5, 0, 8, 0, -3, -2, 0, 4, 0]
head :137 > a.sort { |a, b| -(a<=>b) }
 => [8, 5, 4, 1, 0, 0, 0, 0, 0, -2, -3, -4]

33. Дан целочисленный массив. Найти индекс минимального элемента.
a=[1, 0, -4, 5, 0, 8, 0, -3, -2, 0, 4, 0]
head :139 > a.index(a.min)
 => 2

36. Дан целочисленный массив. Найти индекс первого максимального элемента.
a=[1, 0, -4, 5, 0, 8, 0, -3, -2, 0, 4, 0]
head :139 > a.index(a.max)
 => 5

39. Дан целочисленный массив. Найти количество минимальных элементов.
a=[1,2,3,-3,-3,2,-3]
head :142 > a.select { |item| item==a.min }.size
 => 3

42. Дан целочисленный массив. Найти минимальный нечетный элемент.
a=[1,2,3,-3,-9,2,-1]
head :187 > min=a.max
 => 3
head :188 > a.each { |item| next min if item.even?; min=item if item<min }
 => [1, 2, 3, -3, -9, 2, -1]
head :189 > min
 => -9

45. Дан целочисленный массив. Найти минимальный положительный элемент.
a=[1,2,3,-3,-9,2,-1]
head :190 > min=a.max
 => 3
head :191 > a.each { |item| min=item if(item<min && item>0) }
 => [1, 2, 3, -3, -9, 2, -1]
head :192 > min
 => 1

48. Дан целочисленный массив и интервал a..b. Найти максимальный из элементов в этом интервале.
a=[1,-5,6,4,8,12,2]
1)
2.2.3 :007 > max = range.first
 => 1
2.2.3 :008 > a.each { |item| max = item if(item>max && range.include?(item)) }
 => [1, -5, 6, 4, 8, 12, 2]
2.2.3 :009 > max
 => 8
2)
a.select { |item| range.include?(item) }.max

51. Дан целочисленный массив. Найти количество элементов, расположенных после первого максимального.
a=[1,0,2,3,2,5,6,6,2,1,1]
2.3.0 :013 > a.size - a.index(a.max) - 1
 => 4

54. Дан целочисленный массив. Найти количество элементов, расположенных перед последним минимальным.
a=[1,0,2,3,0,5,6,6,2,1,1]
2.3.0 :016 > a.rindex(a.min)

57. Дан целочисленный массив. Найти индекс первого экстремального (то есть минимального или максимального) элемента.
a=[1,0,2,3,0,5,6,6,2,1,1]
2.3.0 :020 > min_index = a.index(a.min)
 => 1
2.3.0 :021 > max_index = a.index(a.max)
 => 6
2.3.0 :022 > min_index < max_index ? min_index : max_index
 => 1

60. Дан целочисленный массив. Найти количество элементов, между первым и последним максимальным.
a=[1,0,2,6,0,5,6,6,2,1,1]
2.3.0 :026 > a.rindex(a.max) - a.index(a.max) - 1
 => 3

63. Дан целочисленный массив. Найти максимальное количество подряд идущих минимальных элементов.
a=[0,0,2,6,0,5,6,6,0,0,0,0]
min = a.min
find_min = true
min_in_a_row = 0
2.3.0 :036 > a[a.index(min)..a.size-1].each do |item|
2.3.0 :037 >       if item == min
2.3.0 :038?>         find_min = true
2.3.0 :039?>         min_in_a_row += 1
2.3.0 :040?>       else
2.3.0 :041 >           find_min = false
2.3.0 :042?>         min_in_a_row = 0
2.3.0 :043?>       end
2.3.0 :044?>   end
 => [0, 0, 2, 6, 0, 5, 6, 6, 0, 0, 0, 0]
2.3.0 :045 > min_in_a_row
 => 4

66. Дан целочисленный массив. Вывести вначале все его нечетные элементы, а затем - четные.
a=[0,0,2,6,1,5,6,6,5,3,0,0]
2.3.0 :059 > a.select { |item| item.odd? } + a.select { |item| item.even? }
 => [1, 5, 5, 3, 0, 0, 2, 6, 6, 6, 0, 0]

69. Дано вещественное число R и массив вещественных чисел. Найти два элемента массива, сумма которых наиболее близка к данному числу.
a=[1.56, 7.22, 12.1, -1.45, 6.34]
r=11.5
2.3.0 :063 > a.combination(2).to_a.min { |comb| (comb[0]+comb[1]-r).abs }
 => [1.56, 7.22]

72. Дан целочисленный массив. Удалить все элементы, встречающиеся более двух раз.
a=[0,0,2,6,1,5,6,6,5,3,0,0]
2.3.0 :066 > a.uniq
  => [0, 2, 6, 1, 5, 3]
 2.3.0 :070 > a.map.with_object([]) { |item, acc| acc << item if !acc.include?(item) }
 => [0, 2, 6, 1, 5, 3]

75. Дан целочисленный массив. Найти среднее арифметическое модулей его элементов.
a=[1,2,3,-3,-9,2,-1]
head :205 > a.inject(0) { |sum, item| sum+=item.abs }.to_f / a.size
 => 3.0

78. Дано целое число. Найти произведение его цифр.
num=4354628684
head :213 > num.to_s.split('').inject(1) { |res, item| res*=item.to_i }
 => 4423680
2) head :214 > dup = num
 => 4354628684
head :215 > res =1
 => 1
head :216 > while dup != 0 do
head :217 >       res *= dup%10
head :218?>     dup /= 10
head :219?>   end
 => nil
head :220 > res
 => 4423680

81. Дан дипапазон a..b. Получить массив из чисел, расположенных в этом диапазоне (исключая сами эти числа), в порядке их убывания, а также размер этого массива.
head :229 > range=(1..12)
 => 1..12
head :231 > a=range.to_a[1..range.size-2].reverse
 => [11, 10, 9, 8, 7, 6, 5, 4, 3, 2]
head :232 > a.size
 => 10
84. Дано натуральное число N. Найти результат следующего произведения 1*2*…*N.
head :233 > n=5
 => 5
head :234 > def factorial(n)
head :235?>     return 1 if n <= 1
head :236?>     return n * factorial(n-1)
head :237?>   end
 => :factorial
head :238 > factorial n
 => 120
2) head :239 > (1..n).inject(:*)
 => 120

87. Дан целочисленный массив. Найти все четные элементы.
head :240 > a=[2,34,6,7,1,22,343]
 => [2, 34, 6, 7, 1, 22, 343]
head :241 > a.select { |item| item.even? }
 => [2, 34, 6, 22]

90. Дан целочисленный массив. Найти количество нечетных элементов.
a=[2,34,6,7,1,22,343]
head :242 > a.select { |item| item.odd? }.size
 => 3

93. Дан целочисленный массив и число К. Если все элементы массива меньше К, то вывести true; в противном случае вывести false.
